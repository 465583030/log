package log

import (
	"io"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"
)

// These flags define which text to prefix to each log entry generated by the Logger.
const (
	// Bits or'ed together to control what's printed.
	// There is no control over the order they appear (the order listed
	// here) or the format they present (as described in the comments).
	// The prefix is followed by a colon only when Llongfile or Lshortfile
	// is specified.
	// For example, flags Ldate | Ltime (or LStdFlags) produce,
	//	2009/01/23 01:23:23 message
	// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
	//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
	Ldate         = 1 << iota // the date in the local time zone: 2009/01/23
	Ltime                     // the time in the local time zone: 01:23:23
	Lmicroseconds             // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                 // full file name and line number: /a/b/c/d.go:23
	// package and file name and line number: package/file.go:23, remove /opt/gowork/src/github.com/gotips/log/
	Lprojectfile
	Lshortfile                                // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                                      // if Ldate or Ltime is set, use UTC rather than the local time zone
	LStdFlags  = Ldate | Ltime | Lprojectfile // initial values for the standard logger
)

// A Standard Logger represents an active logging object that generates lines of
// output to an io.Writer.  Each logging operation makes a single call to
// the Writer's Write method.  A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type Standard struct {
	mu   sync.Mutex // ensures atomic writes; protects the following fields
	flag int        // properties
	out  io.Writer  // destination for output
	buf  []byte     // for accumulating text to write
}

// NewStandard creates a new Logger.   The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func NewStandard(out io.Writer, flag int) *Standard {
	return &Standard{out: out, flag: flag}
}

// SetWriter sets the output destination for the logger.
func (s *Standard) SetWriter(w io.Writer) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.out = w
}

// SetFlags sets the output flags for the logger.
func (s *Standard) SetFlags(flag int) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.flag = flag
}

// Print writes the output for a logging event.  The string s contains
// the text to print after the prefix specified by the flags of the
// Logger.  A newline is appended if the last character of s is not
// already a newline.  Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 3.
func (s *Standard) Print(l Level, m string) error {
	now := time.Now() // get this early.

	var file string
	var line int
	if s.flag&(Lprojectfile|Lshortfile|Llongfile) != 0 {
		var ok bool
		_, file, line, ok = runtime.Caller(3) // expensive
		if !ok {
			file = "???"
			line = 0
		}
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	s.buf = s.buf[:0] // clear previous log

	s.buf = s.formatHeader(s.buf, now, l, file, line) // header
	s.buf = append(s.buf, m...)                       // message

	if len(m) == 0 || m[len(m)-1] != '\n' { // append \n
		s.buf = append(s.buf, '\n')
	}

	_, err := s.out.Write(s.buf)
	return err
}

func (s *Standard) formatHeader(buf []byte, t time.Time, l Level, file string, line int) []byte {
	if s.flag&LUTC != 0 {
		t = t.UTC()
	}

	tstr := t.Format("2006-01-02 15:04:05.000000")
	if s.flag&Ldate != 0 {
		buf = append(buf, tstr[:10]...)
	}
	if s.flag&Ltime != 0 {
		buf = append(buf, tstr[10:19]...)
	}
	if s.flag&Lmicroseconds != 0 {
		buf = append(buf, tstr[19:]...)
	}
	buf = append(buf, ' ')

	buf = append(buf, Labels[l]...)
	buf = append(buf, ' ')

	if s.flag&Lprojectfile != 0 {
		idx := strings.LastIndex(file, "github.com/")
		if idx < 0 {
			idx = strings.LastIndex(file, "src/")
			if idx > 0 {
				file = file[idx+4:]
			}
			// else long file
		} else {
			// if pkg contains github.com, remove it
			file = file[idx+11:]
			file = file[strings.Index(file, "/")+1:] // remove github accout name
			file = file[strings.Index(file, "/")+1:] // remove github project name
		}
	} else if s.flag&Lshortfile != 0 {
		file = file[strings.LastIndex(file, "/")+1:]
	}
	// else long file
	buf = append(buf, file...)
	buf = append(buf, ':')
	buf = append(buf, strconv.Itoa(line)...)
	buf = append(buf, ' ')

	return buf
}
